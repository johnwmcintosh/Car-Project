Robot Motor Control Engineering Manual
Raspberry Pi Pico 2 + DRV8871 + 12 V SLA System
Version 1.0
Author: John  
Technical Companion: Microsoft Copilot  
Date: Dec 30 2025

---
Document Purpose

This manual provides a complete, safe, and reproducible engineering reference for a three‑motor robotic platform powered by a 12 V SLA battery, controlled by a Raspberry Pi Pico 2, and supervised by a Raspberry Pi 5 running ROS.  
It includes wiring diagrams, power‑delivery engineering, motor‑driver protection, firmware architecture, ROS integration, debugging methodology, and lessons learned from real hardware failures.

This is a hybrid‑style document:
• Formal engineering sections for clarity and reproducibility
• Lessons Learned callouts capturing practical insights from real‑world testing
---

Revision History

+----------+------------+-----------------------------------------------+
| Version  | Date       | Description                                   |
+----------+------------+-----------------------------------------------+
| 1.0      | 12/30/2025 | Initial release of full engineering manual    |
+----------+------------+-----------------------------------------------+

=============================================
SECTION 1 — TITLE PAGE, REVISION HISTORY, TOC
=============================================

1. System Overview
2. Required Components
3. Safety Principles
4. Wiring Architecture
5. Power Delivery Engineering
6. Raspberry Pi 5 Power Lessons
7. Motor Control Theory
8. Encoder System
9. Pico 2 Firmware Architecture
   9.13 Full Pico 2 Firmware (C/C++ Sketch)
10. ROS Integration
11. Bench Testing Procedure
12. Troubleshooting
13. Future Improvements
14. Bill of Materials (BOM)
15. Appendices
    A. Pi 5 USB‑C Power Lessons
    B. Short Wire Pathways
    C. ROS Architecture Restructuring
    D. ROS Integration Details

==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

===============================================
SECTION 2 — SYSTEM OVERVIEW, COMPONENTS, SAFETY
===============================================

---
1. System Overview

This robot uses a distributed control architecture designed for reliability, electrical safety, and clean integration with ROS.

High‑Level Architecture
• Raspberry Pi 5  

Runs ROS, navigation, mapping, autonomy, and high‑level command logic.
• Raspberry Pi Pico 2  
Handles all real‑time motor control, PWM generation, direction logic, encoder reading, watchdog behavior, and safety cutoffs.

• Three DRV8871 Motor Drivers  
Each driver controls one 12 V DC gear motor.

• 12 V SLA Battery (Mighty Max ML5‑12)  
Primary power source for motors and buck converter.

• TOBSUN 12 V → 5 V 10 A Buck Converter  
Dedicated, isolated supply for the Raspberry Pi 5.

• Protection Components  
Fuses, bulk capacitors, snubbers, TVS diodes, and proper grounding strategy.

Control Flow
ROS (Pi 5) → USB Serial → Pico 2 → DRV8871 → Motors
Pico 2 → USB Serial → Pi 5 (Encoder Feedback)

Power Flow
12 V SLA → Fuses → Motor Drivers → Motors
12 V SLA → Buck Converter → 5 V → Pi 5


---
2. Required Components

Below is the complete list of hardware used in the system.  
A more detailed Bill of Materials appears later in Section 14.

Core Electronics
• Raspberry Pi 5
• Raspberry Pi Pico 2
• 3 × DRV8871 motor drivers
• Mighty Max ML5‑12 SLA battery
• TOBSUN 12 V → 5 V 10 A buck converter
• USB‑A to USB‑C cable (data‑capable)
• USB‑A to Micro‑USB cable (for Pico 2)

Protection Components
• 3 × 2–5 A fuses (one per motor driver)
• 1 × 5–10 A fuse for Pi 5 power rail
• 3 × 470–1000 µF bulk capacitors (per motor driver)
• 3 × RC snubbers (per motor)
• 1 × 5 V TVS diode for Pi 5
• 1 × 12 V TVS diode for motor rail

Wiring & Connectors
• 16–20 AWG silicone wire (power)
• 22–26 AWG wire (signal)
• Crimp connectors
• Screw terminals
• Heat‑shrink tubing
• Ferrules (optional but recommended)

Tools
• Multimeter
• Soldering iron
• Helping hands with integrated magnifying glass and light
• Crimping tool
• Wire strippers
• Laser printer (for this manual!)


---
3. Safety Principles

This system was designed with electrical safety and fault tolerance as first‑class requirements.  
The following principles guide all wiring and power decisions.


---
3.1 Isolation of High‑Current and Logic Systems

The Raspberry Pi 5 must never share high‑current return paths with motors.
Rules
• Motor ground returns directly to the battery.
• Pi 5 ground returns directly to the buck converter.
• The only connection between logic and motor systems is signal ground, kept short and low‑impedance.


---
3.2 Fusing Strategy

Every subsystem must be fused to prevent catastrophic failures.
Fuse Locations
• One fuse per motor driver
• One fuse on the Pi 5’s 5 V input
• Optional: one fuse on the main battery output
Fuse Purpose
• Protect wiring
• Prevent fires
• Limit damage during shorts
• Prevent repeat of previous Pi 5 damage events


---
3.3 Protection Against Voltage Spikes

DC motors generate:
• Back‑EMF
• Inductive kickback
• High‑frequency noise
Protection components include:
• Bulk capacitors
• RC snubbers
• TVS diodes
• Short, thick wiring
• Proper grounding

These dramatically reduce electrical stress on the Pico 2 and Pi 5.

	
---
3.4 Avoiding USB‑C Power for the Pi 5

The Pi 5’s USB‑C PD input is not suitable for noisy motor environments.
Reasons
• PD negotiation instability
• Noise coupling through cable shield
• Brownouts
• GPIO latch‑ups
• Permanent damage (observed)

The Pi 5 is instead powered from a dedicated 5 V rail with short, thick wiring.


---
3.5 Bench Testing Before Integration

Every subsystem must be tested independently before connecting to the robot.
Bench Tests Include
• Buck converter output stability
• Pico 2 PWM and direction logic
• DRV8871 behavior under load
• Motor current measurement
• Encoder signal integrity
• USB serial communication
• ROS node behavior

Lessons Learned (Sidebar)

During early testing, powering the Pi 5 through USB‑C caused
multiple brownouts, USB resets, and eventually permanent GPIO
damage. The root cause was noise coupling through the USB‑C
cable shield and PD negotiation instability.

Switching to a dedicated 5 V rail with short, thick wiring
eliminated all instability.

Reverse polarity on the TOBSUN buck converter destroyed the
module instantly. This led to the addition of polarity
protection and fuses on all power rails.

Long power wires to the Pi 5 caused voltage sag during motor
startup. Shortening the wires to under 6 inches completely
resolved the issue.

Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

================================================
SECTION 3 — WIRING ARCHITECTURE (ASCII DIAGRAMS)
================================================

---
4. Wiring Architecture

This section describes the complete wiring layout for the robot, including power distribution, grounding, motor driver wiring, and logic‑level connections.
All diagrams are ASCII‑based to ensure perfect alignment in TextEdit.


---
4.1 High‑Level Wiring Diagram

+---------------------------+
                 |     Raspberry Pi 5        |
                 |   (ROS, Navigation, etc.) |
                 +-------------+-------------+
                               |
                               | USB Serial
                               |
                 +-------------+-------------+
                 |     Raspberry Pi Pico 2    |
                 | (PWM, Encoders, Watchdog)  |
                 +------+------+------+-------+
                        |      |      |
                        |      |      |
                +-------+  +---+--+  +--------+
                | DRV8871 | DRV8871 | DRV8871 |
                +----+----+----+----+----+----+
                     |         |         |
                     |         |         |
                 Motor 1   Motor 2   Motor 3


---
4.2 Power Distribution Diagram

+---------------------------+
                 |   12 V SLA Battery        |
                 +-------------+-------------+
                               |
                               | Main Fuse (5–10 A)
                               |
                 +-------------+-------------+
                 |     Power Distribution     |
                 +------+------+------+-------+
                        |      |      |
                        |      |      |
                +-------+  +---+--+  +--------+
                | Fuse  |  | Fuse |  | Fuse   |
                | 2–5 A |  | 2–5 A|  | 2–5 A  |
                +---+---+  +---+--+  +---+----+
                    |         |         |
                +---+---+ +---+---+ +---+---+
                |DRV8871| |DRV8871| |DRV8871|
                +---+---+ +---+---+ +---+---+
                    |         |         |
                 Motor 1   Motor 2   Motor 3

                        (Logic Power)
                               |
                               |
                 +-------------+-------------+
                 |  TOBSUN 12→5 V Buck Conv. |
                 +-------------+-------------+
                               |
                               | 5 V (short, thick wires)
                               |
                 +-------------+-------------+
                 |        Raspberry Pi 5      |
                 +----------------------------+


---
4.3 Grounding Strategy

Proper grounding is essential for preventing noise, brownouts, and hardware damage.

Rules

• Motor ground returns directly to the battery.
• Pi 5 ground returns directly to the buck converter.
• Pico 2 ground ties to Pi 5 ground through USB cable.
• Motor driver logic ground ties to Pico 2 ground.
• No high‑current ground should ever pass through the Pi 5.

ASCII Ground Map

Battery (-)
               |
               +-------------------------------+
               |                               |
         Motor Ground (High Current)      Buck Converter Ground
               |                               |
      +--------+--------+                      |
      |        |        |                      |
   DRV8871  DRV8871  DRV8871                   |
      |        |        |                      |
      +--------+--------+                      |
               |                               |
               +-------------------------------+
                               |
                               | Logic Ground
                               |
                        +------+------+
                        |   Pico 2    |
                        +------+------+
                               |
                               | USB Ground
                               |
                        +------+------+
                        |    Pi 5     |
                        +-------------+


---
4.4 Motor Driver Wiring (DRV8871)

Each DRV8871 requires:
• 2 PWM/direction pins from the Pico 2
• 12 V motor power
• Ground
• Bulk capacitor
• Snubber across motor terminals

ASCII Diagram

+----------------------+
                |      DRV8871         |
                +----------------------+
                | IN1  <-- Pico GPIO A |
                | IN2  <-- Pico GPIO B |
                | GND  ---------------+-------------------+
                | VM   <-- 12 V (fused)                   |
                | OUT1 ---- Motor Terminal 1              |
                | OUT2 ---- Motor Terminal 2              |
                +----------------------+


---
4.5 Pico 2 Wiring

The Pico 2 handles:
• PWM generation
• Direction logic
• Encoder reading
• Watchdog
• Serial communication

+-------------------------------+
|         Raspberry Pi Pico 2   |
+-------------------------------+
| USB --> Pi 5                  |
| GND --------------------------+ (Logic Ground)
|                               |
| GPIO 2  --> M1 IN1            |
| GPIO 3  --> M1 IN2            |
| GPIO 4  --> M2 IN1            |
| GPIO 5  --> M2 IN2            |
| GPIO 6  --> M3 IN1            |
| GPIO 7  --> M3 IN2            |
|                               |
| GPIO 10 --> Encoder 1 A       |
| GPIO 11 --> Encoder 1 B       |
| GPIO 12 --> Encoder 2 A       |
| GPIO 13 --> Encoder 2 B       |
| GPIO 14 --> Encoder 3 A       |
| GPIO 15 --> Encoder 3 B       |
+-------------------------------+


---
4.6 Pi 5 Power Wiring (Critical)

The Pi 5 must be powered through:
• Short, thick 5 V wires
• Direct connection to buck converter
• No USB‑C power
• Dedicated fuse

ASCII Diagram

Buck Converter 5 V Out (+) ---- Fuse ----> Pi 5 5 V Pin
Buck Converter GND ---------------> Pi 5 GND Pin

Wire length: under 6 inches  
Wire gauge: 18 AWG recommended

Lessons Learned (Sidebar)

Long power wires to the Pi 5 caused voltage sag during motor
startup. Shortening the wires to under 6 inches eliminated
brownouts and USB resets.

Motor ground must never pass through the Pi 5. Early wiring
mistakes caused noise to couple into USB and GPIO, leading to
instability and hardware damage.

Bulk capacitors and snubbers dramatically reduced motor noise.
Without them, the DRV8871 drivers produced large voltage spikes
that affected the Pico 2 and Pi 5.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 4 — POWER DELIVERY ENGINEERING
============================================


---
5. Power Delivery Engineering
This section details the electrical engineering principles that ensure stable, safe, and noise‑resistant operation of the robot.

It includes capacitor selection, snubber design, fuse sizing, wire gauge recommendations, and grounding strategy.

---
5.1 Overview of Power Requirements

The robot uses a 12 V SLA battery as the primary power source.  
From this, two major power domains are derived:
Motor Power Domain (12 V)
• High current
• High noise
• Inductive loads
• Requires heavy filtering and protection
Logic Power Domain (5 V)
• Clean, stable
• Low noise
• Sensitive to voltage dips
• Must be isolated from motor noise


---
5.2 Bulk Capacitors (Per Motor Driver)

Bulk capacitors absorb sudden current spikes and reduce voltage sag.

Recommended Value
• 470–1000 µF electrolytic capacitor
• Voltage rating: 25 V or higher
• ESR: Low ESR preferred

Placement

Battery (+) ---- Fuse ---- DRV8871 VM Pin
                         |
                         +---- 470–1000 µF ---- Ground

Purpose
• Smooths motor startup current
• Reduces brownouts
• Protects DRV8871 from voltage dips
• Reduces noise coupling into logic systems


---
5.3 Snubbers (RC Networks)

Snubbers suppress high‑frequency noise generated by motor commutation.

Recommended Snubber
• 0.1 µF ceramic capacitor
• 100 Ω resistor
• Wired in series across motor terminals

ASCII Diagram

Motor Terminal 1 ----[100 Ω]----+---- Motor Terminal 2
                                |
                             [0.1 µF]
                                |
                              Ground

Motor Terminal 1 ----[100 Ω]----+---- Motor Terminal 2
                                |
                             [0.1 µF]
                                |
                              Ground
Purpose

• Reduces EMI
• Protects DRV8871
• Prevents encoder noise
• Reduces USB instability


---
5.4 TVS Diodes

TVS diodes clamp dangerous voltage spikes.

Recommended Devices

• 12 V TVS diode on motor rail
• 5 V TVS diode on Pi 5 rail

ASCII Diagram

12 V Rail ----+---- TVS (12 V) ---- Ground
              |
              +---- Motor Drivers


5 V Rail -----+---- TVS (5 V) ---- Ground
              |
              +---- Pi 5

Purpose

• Protects against inductive kickback
• Prevents overvoltage events
• Protects buck converter and Pi 5


---
5.5 Fuse Sizing

Fuses protect wiring and prevent catastrophic failures.

Motor Driver Fuses
• 2–5 A per motor driver
• Fast‑acting recommended

Pi 5 Fuse
• 5–10 A
• Slow‑blow recommended (to avoid nuisance trips)

Main Battery Fuse
• 10–15 A
• Optional but recommended

ASCII Diagram

Battery (+)
   |
   +---- Main Fuse (10–15 A)
           |
           +---- Motor Fuses (2–5 A each)
           |        |
           |     DRV8871
           |
           +---- Pi 5 Fuse (5–10 A)
                    |
                 Buck Converter → Pi 5


---
5.6 Wire Gauge Selection

Motor Power Wires

• 16–20 AWG
• Silicone insulation recommended
• Keep under 12 inches if possible

Pi 5 Power Wires

• 18 AWG
• Keep under 6 inches
• Twisted pair recommended

Signal Wires

• 22–26 AWG
• Keep encoder wires twisted
• Keep PWM wires short


---
5.7 Short‑Wire Power Strategy (Critical)

The Pi 5 is extremely sensitive to voltage sag.  

Long wires cause:
• Brownouts
• USB resets
• GPIO latch‑ups
• Permanent damage (observed)

Rule
Pi 5 power wires must be under 6 inches.

ASCII Diagram

Buck Converter
   |
   +---- 5 V (18 AWG, <6") ----> Pi 5 5 V Pin
   |
   +---- GND (18 AWG, <6") ----> Pi 5 GND Pin


---
5.8 Noise Mitigation Summary

Motor Noise Sources

• Commutation
• Back‑EMF
• Inductive kickback
• Rapid load changes

Mitigation Tools

• Bulk capacitors
• Snubbers
• TVS diodes
• Short wires
• Proper grounding
• Separate power domains
• Shielded encoder wires

Lessons Learned (Sidebar)

The Pi 5 suffered permanent GPIO damage when powered through
USB‑C during motor testing. The root cause was noise coupling
through the cable shield and PD negotiation instability.

Reverse polarity instantly destroyed the TOBSUN buck converter.
This led to the addition of polarity protection and fuses on
every power rail.

Bulk capacitors and snubbers dramatically reduced motor noise.
Before adding them, the DRV8871 drivers produced spikes that
caused USB resets and encoder glitches.

Shortening the Pi 5 power wires to under 6 inches completely
eliminated brownouts and USB instability.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 5 — RASPBERRY PI 5 POWER LESSONS
============================================

---
6. Raspberry Pi 5 Power Lessons

This section documents the real‑world failures, electrical behavior, and engineering insights gained from powering the Raspberry Pi 5 in a motor‑driven robotics environment.  
These lessons directly informed the final power architecture used in this robot.


---
6.1 Why the Pi 5 Is Sensitive

The Raspberry Pi 5 is significantly more sensitive to power quality than previous models due to:

• Higher CPU/GPU power draw
• USB‑C PD negotiation circuitry
• More complex power‑management ICs
• Higher transient current spikes
• Tighter voltage tolerances
• Increased susceptibility to ground noise

In a robotics environment with motors, inductive loads, and switching converters, these sensitivities become critical.


---
6.2 USB‑C Power Input Problems

Early testing revealed that powering the Pi 5 through USB‑C caused:

• Brownouts
• USB resets
• Kernel panics
• GPIO latch‑ups
• Permanent GPIO damage
• Unpredictable behavior under motor load

Root Causes

1. PD negotiation instability  
The Pi 5 negotiates power profiles with the USB‑C source.  
Motor noise disrupted this negotiation, causing voltage dips.

2. Cable shield noise coupling  
Motor noise traveled along the USB‑C cable shield into the Pi 5.

3. Voltage sag under load  
USB‑C cables have higher resistance than short, thick wires.

4. Shared ground paths  
USB‑C ground is not isolated from noisy motor ground.


---
6.3 Failure Case Study: GPIO Destruction

During early testing, the Pi 5 experienced:
• Smoke event
• Permanent GPIO pin failure
• Loss of multiple pins
• Unrecoverable hardware damage

Root Cause Analysis
• Motor noise and back‑EMF entered the Pi 5 ground through USB‑C.
• A transient spike exceeded GPIO absolute maximum ratings.
• The Pi 5’s internal protection diodes were overwhelmed.
• The GPIO rail partially shorted internally.

Outcome
This event led to the complete redesign of the power system.


---
6.4 Short‑Wire Power Delivery (Critical Discovery)

After extensive testing, the single most important improvement was:
Pi 5 power wires must be under 6 inches.

Longer wires caused:

• Voltage sag
• Brownouts
• USB resets
• Kernel warnings
• Random reboots
• ROS node crashes

Why short wires matter

• Lower resistance
• Lower inductance
• Faster transient response
• Less voltage drop during motor startup
• Less noise pickup

ASCII Diagram

Buck Converter
   |
   +---- 5 V (18 AWG, <6") ----> Pi 5 5 V Pin
   |
   +---- GND (18 AWG, <6") ----> Pi 5 GND Pin

This configuration eliminated all instability.


---
6.5 Why the Buck Converter Must Be Dedicated

The Pi 5 must have its own isolated 5 V supply.

Reasons

• Prevents motor noise from entering logic domain
• Prevents ground bounce
• Prevents voltage sag
• Prevents USB resets
• Prevents GPIO damage

Buck Converter Requirements

• 10 A rating (TOBSUN)
• Reverse polarity protection
• Short, thick output wires
• Clean ground return path


---
6.6 Reverse Polarity Event Analysis

A reverse polarity connection destroyed the TOBSUN buck converter instantly.

Symptoms

• No output
• Burnt smell
• Internal short
• Converter permanently dead

Root Cause

• No reverse polarity protection
• SLA battery can deliver extremely high fault current
• Converter’s input stage was not protected

Fix

• Add polarity protection
• Add fuses
• Add TVS diodes


---
6.7 USB Instability and Motor Noise

Before the power redesign, the Pi 5 experienced:

• USB disconnects
• RPLIDAR enumeration failures
• Serial port resets
• Kernel logs showing “USB device not accepting address”
• ROS nodes crashing due to lost devices

Root Cause

Motor noise coupled into:

• USB ground
• USB shield
• Pi 5 internal ground plane
• Pi 5 PMIC

Fix

• Dedicated 5 V rail
• Short wires
• Snubbers
• Bulk capacitors
• TVS diodes
• Proper grounding


---
6.8 Final Pi 5 Power Architecture

12 V SLA Battery
   |
   +---- Fuse (5–10 A)
           |
           +---- TOBSUN Buck Converter (12→5 V)
                     |
                     +---- 5 V (18 AWG, <6") ----> Pi 5 5 V Pin
                     |
                     +---- GND (18 AWG, <6") ----> Pi 5 GND Pin

This architecture has proven:

• Stable
• Noise‑resistant
• Safe
• Repeatable
• Robust under motor load

Lessons Learned (Sidebar)

USB‑C is not suitable for powering the Pi 5 in a robotics
environment. Noise coupling and PD negotiation instability
caused brownouts and permanent hardware damage.

Shortening the Pi 5 power wires to under 6 inches completely
eliminated voltage sag and USB instability.

Reverse polarity destroyed the buck converter instantly. This
led to the addition of polarity protection and fuses on all
power rails.

A dedicated 5 V rail for the Pi 5 is mandatory. Sharing power
with motors is a guaranteed failure mode.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 6 — MOTOR CONTROL THEORY
============================================

---
7. Motor Control Theory

This section explains how DC motors behave electrically and mechanically, how the DRV8871 controls them, and how the Pico 2 generates the PWM and direction signals that drive the system.

Understanding these principles is essential for safe, predictable, and efficient motor control.

---
7.1 DC Motor Fundamentals

A brushed DC motor converts electrical energy into mechanical rotation using:

• A wound armature
• A commutator
• Brushes
• Permanent magnets

Key Electrical Properties

• Back‑EMF: Voltage generated by the motor as it spins
• Stall Current: Maximum current when the motor is not moving
• Running Current: Current during normal operation
• Inductance: Causes voltage spikes when current changes rapidly

Key Mechanical Properties

• Torque: Proportional to current
• Speed: Proportional to applied voltage minus back‑EMF
• Load: Affects both current and speed


---
7.2 PWM (Pulse‑Width Modulation)

PWM controls motor speed by rapidly switching the motor supply on and off.

Duty Cycle

0%   = motor off
50%  = half speed (approx)
100% = full speed

Why PWM Works

The motor’s inductance smooths the pulses, creating an effective average voltage.

Recommended PWM Frequency

• 20–25 kHz
• Above audible range
• Reduces whining noise
• Works well with DRV8871


---
7.3 Direction Control

The DRV8871 uses two input pins:

• IN1
• IN2

Truth Table

IN1   IN2   Motor Behavior
--------------------------
 0     0    Brake (low)
 1     0    Forward
 0     1    Reverse
 1     1    Brake (high)

Pico 2 Implementation

• One pin outputs PWM
• The other pin sets direction
• Or both pins can be PWM’d for finer control


---
7.4 DRV8871 Behavior

The DRV8871 is a half‑bridge motor driver with:

• Overcurrent protection
• Thermal shutdown
• Undervoltage lockout
• Integrated MOSFETs

Voltage Range

• Up to 38 V
• Perfect for 12 V SLA systems

Current Capability

• 3.6 A peak
• 2 A continuous (with cooling)

Why It Works Well Here

• Simple interface
• Robust protection
• Good efficiency
• Handles inductive loads well


---
7.5 Motor Startup Behavior

When a motor starts:

• Back‑EMF = 0
• Current = stall current
• Torque = maximum

This causes:
• Large current spikes
• Voltage dips
• Noise injection

Mitigation
• Bulk capacitors
• Snubbers
• TVS diodes
• Fuses
• Soft‑start PWM ramping


---
7.6 Soft‑Start Ramping

To avoid sudden current spikes, the Pico 2 gradually increases PWM duty cycle.

Example Ramp

0% → 10% → 20% → 30% → ... → target speed

Benefits

• Reduces stress on DRV8871
• Reduces voltage sag
• Prevents Pi 5 brownouts
• Improves motor longevity


---
7.7 Stall Current and Fuse Selection

Stall current is the maximum current a motor draws when it cannot turn.

Why Stall Current Matters

• Determines fuse size
• Determines DRV8871 thermal load
• Determines wire gauge
• Determines capacitor size


---
7.8 Motor Noise and Electrical Spikes

DC motors generate:

• High‑frequency switching noise
• Back‑EMF
• Inductive kickback
• Commutation spikes

Noise Mitigation Tools

• Bulk capacitors
• Snubbers
• TVS diodes
• Short wires
• Proper grounding
• Shielded encoder wires


---
7.9 Why the Pico 2 Is the Right Choice

The Pico 2 excels at:

• Real‑time PWM
• Low‑latency direction control
• PIO‑based encoder reading
• Hardware timers
• Deterministic behavior
• Low noise sensitivity

Advantages Over Pi 5 GPIO

• No OS jitter
• No USB noise coupling
• No kernel scheduling delays
• No risk of GPIO damage from motor noise

---
7.10 Summary of Motor Control Architecture

Pico 2
  |
  +-- PWM + Direction --> DRV8871
                                |
                                +-- Motor

Key Principles

• PWM controls speed
• Direction pins control rotation
• Bulk capacitors smooth current
• Snubbers suppress noise
• TVS diodes protect electronics
• Fuses prevent catastrophic failures

Lessons Learned (Sidebar)

Early tests without soft-start ramping caused large current
spikes that led to Pi 5 brownouts. Adding ramping eliminated
these issues.

The DRV8871’s built-in protection saved the system multiple
times during wiring mistakes and stall events.

Motor noise is not a small problem. Without snubbers and bulk
capacitors, the system experienced USB resets, encoder glitches,
and unpredictable behavior.

The Pico 2 is the correct place for all real-time motor control.
The Pi 5 cannot reliably handle PWM or direction logic in a
noisy environment.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

=============================================
SECTION 7 — ENCODER SYSTEM (QUADRATURE + PIO)
=============================================

---
8. Encoder System

Encoders provide the robot with wheel rotation feedback, enabling closed‑loop control, odometry, and precise motion.  
This section explains how quadrature encoders work, how to wire them, and how the Pico 2 uses PIO to decode them with perfect reliability.

8.1 What a Quadrature Encoder Is

A quadrature encoder outputs two square‑wave signals:

• Channel A
• Channel B

These signals are offset by 90° (a quarter cycle), allowing the controller to determine:

• Rotation amount
• Rotation direction
• Speed

ASCII Timing Diagram

A:  ┌──┐    ┌──┐    ┌──┐
    │  │    │  │    │  │
────┘  └────┘  └────┘  └──

B:     ┌──┐    ┌──┐    ┌──┐
       │  │    │  │    │  │
───────┘  └────┘  └────┘  └─

Direction Detection

• If A leads B → forward
• If B leads A → reverse


---
8.2 Why Encoders Matter

Encoders allow:

• Closed‑loop speed control
• Accurate odometry
• Smooth acceleration
• Straight‑line correction
• Stall detection
• Motor health monitoring

Without encoders, the robot would drift, slip, and lose positional accuracy.


---
8.3 Electrical Characteristics

Most small DC gearmotors with encoders output:

• 5 V logic
• Open‑collector or push‑pull outputs
• ~100–1000 pulses per revolution (varies by model)

Noise Sensitivity

Encoder signals are very sensitive to:
• Motor noise
• Ground bounce
• Long wires
• EMI

This is why proper wiring and filtering are essential.


---
8.4 Wiring Encoders to the Pico 2

Each encoder has:

• A channel
• B channel
• VCC (5 V)
• GND

ASCII Wiring Diagram

Encoder A ----> Pico GPIO (e.g., 10)
Encoder B ----> Pico GPIO (e.g., 11)
Encoder VCC --> 5 V
Encoder GND --> Logic Ground

Rules

• Keep wires short
• Twist A/B together
• Twist VCC/GND together
• Avoid running encoder wires next to motor wires
• Add 0.1 µF ceramic capacitor across VCC/GND at the encoder


---
8.5 Signal Integrity Considerations

Problems Without Proper Wiring

• Missed pulses
• False direction changes
• Jitter
• ROS odometry drift
• Motor oscillation

Fixes

• Twisted pairs
• Shielded cable (optional)
• Ceramic bypass capacitors
• Clean ground return
• Snubbers on motors
• Bulk capacitors on drivers


---
8.6 Why PIO Is Perfect for Encoders

The Raspberry Pi Pico 2 includes Programmable I/O (PIO) blocks that can:

• Sample signals at high speed
• Decode quadrature in hardware
• Offload CPU
• Guarantee deterministic timing
• Avoid jitter from interrupts

Benefits

• Zero missed pulses
• Zero CPU overhead
• Perfect direction detection
• Works even at high RPM


---
8.7 PIO Quadrature Decoder Logic

The PIO state machine monitors A and B transitions.

State Table

Prev AB | New AB | Action
--------------------------
   00   |   01   | +1
   01   |   11   | +1
   11   |   10   | +1
   10   |   00   | +1

   00   |   10   | -1
   10   |   11   | -1
   11   |   01   | -1
   01   |   00   | -1

Why This Works

Each transition corresponds to a 90° rotation step.


---
8.8 Encoder Count Scaling

If the encoder outputs N pulses per revolution, quadrature decoding yields:

• 4 × N counts per revolution

Example:

• 100 PPR encoder → 400 counts per revolution
• 300 PPR encoder → 1200 counts per revolution

This increases resolution dramatically.

---
8.9 Integrating Encoders with Motor Control
The Pico 2 uses encoder feedback to:
• Maintain target speed
• Detect stalls
• Detect slippage
• Provide odometry to ROS
• Smooth acceleration and deceleration

Control Loop

Encoder → Pico 2 → Speed Controller → PWM Output → Motor


---
8.10 Encoder Failure Modes

Common Issues

• Loose ground
• Noise on A/B lines
• Broken wire
• Motor noise coupling
• Incorrect pull‑ups
• Damaged encoder disk

Symptoms

• Erratic counts
• Zero counts
• Direction flipping
• ROS odometry drift

Fixes

• Re‑terminate wires
• Add bypass capacitors
• Add snubbers
• Improve grounding
• Shorten wires

Lessons Learned (Sidebar)

Encoder noise was a major source of odometry drift until
snubbers and bulk capacitors were added to the motor drivers.

Twisting A/B wires together dramatically improved signal
integrity and eliminated false direction changes.

PIO-based decoding is rock solid. Interrupt-based decoding on
the Pi 5 was unreliable due to OS jitter and USB noise.

Adding a 0.1 µF ceramic capacitor across encoder VCC/GND at the
sensor reduced high-frequency noise and stabilized counts.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 8 — PICO 2 FIRMWARE ARCHITECTURE
============================================

---
9. Pico 2 Firmware Architecture

The Raspberry Pi Pico 2 is the real‑time control brain of the robot.  
It handles all timing‑critical tasks that the Pi 5 cannot reliably perform in a noisy motor environment.

This section describes the firmware architecture, task scheduling, safety logic, and communication protocol.


---
9.1 Why the Pico 2 Handles Motor Control

The Pi 5 runs a full operating system, which introduces:

• Scheduling jitter
• Interrupt latency
• USB noise coupling
• Kernel timing unpredictability

The Pico 2, by contrast:

• Runs bare‑metal or lightweight RTOS
• Has deterministic timing
• Has PIO for hardware‑level tasks
• Is electrically isolated from motor noise
• Is cheap and easy to replace

Conclusion

All real‑time motor control belongs on the Pico 2.


---
9.2 Firmware Responsibilities

The Pico 2 handles:

Motor Control

• PWM generation
• Direction logic
• Soft‑start ramping
• Stall detection

Encoder Processing

• PIO quadrature decoding
• Count accumulation
• Speed calculation

Safety

• Watchdog timer
• Overcurrent detection (via DRV8871 fault pin)
• Emergency stop logic

Communication
• USB serial link to Pi 5
• Command parsing
• Encoder feedback reporting


---
9.3 Firmware Architecture Overview

+-----------------------------------------------+
|                Main Loop                      |
+-----------------------------------------------+
| - Read commands from Pi 5                     |
| - Update motor targets                        |
| - Read encoder counts                         |
| - Compute speed feedback                      |
| - Apply safety checks                         |
| - Send telemetry to Pi 5                      |
+-----------------------------------------------+

+---------------------+   +---------------------+
| PWM Generator       |   | Direction Controller|
+---------------------+   +---------------------+

+---------------------+   +---------------------+
| PIO Quadrature      |   | Watchdog Timer      |
| Decoder             |   |                     |
+---------------------+   +---------------------+


---
9.4 PWM Generation

Each motor uses one PWM pin and one direction pin.

PWM Requirements

• Frequency: 20–25 kHz
• Resolution: 8–12 bits
• Duty cycle: 0–100%

Soft‑Start Ramping

PWM ramps up gradually to avoid current spikes.

ASCII Diagram

Target PWM: 80%

Ramp:
0% → 10% → 20% → 40% → 60% → 80%


---
9.5 Direction Logic

The DRV8871 uses two input pins:

• IN1
• IN2

Truth Table

IN1   IN2   Behavior
--------------------
 0     0    Brake
 1     0    Forward
 0     1    Reverse
 1     1    Brake

The Pico 2 sets these pins based on the command from the Pi 5.


---
9.6 Encoder Integration

The Pico 2 uses PIO to decode quadrature signals.

PIO Advantages

• Zero missed pulses
• No CPU overhead
• Perfect direction detection
• Works at high RPM

Data Flow

PIO → Encoder Count → Speed Calculation → Motor Control Loop


---
9.7 Speed Calculation

Speed is computed using:

• Encoder counts
• Time delta
• Counts per revolution
• Wheel circumference

Formula

speed = (delta_counts / counts_per_rev) * wheel_circumference / delta_time


---
9.8 Watchdog Timer

The watchdog ensures the robot stops if communication is lost.

Behavior

• If Pi 5 stops sending commands → motors stop
• Timeout: 100–200 ms
• Prevents runaway motors

ASCII Diagram

Pi 5 Command → [Reset Watchdog]
No Command → [Watchdog Expires] → Motors Off


---
9.9 DRV8871 Fault Handling

The DRV8871 exposes a FAULT pin.

Fault Conditions

• Overcurrent
• Thermal shutdown
• Undervoltage

Firmware Response

• Immediately stop motor
• Report fault to Pi 5
• Wait for reset command


---
9.10 USB Serial Protocol

The Pico 2 communicates with the Pi 5 using a simple, robust serial protocol.

Command Format

SET M1 <duty> <direction>
SET M2 <duty> <direction>
SET M3 <duty> <direction>

Telemetry Format

ENC <m1_count> <m2_count> <m3_count>
SPD <m1_speed> <m2_speed> <m3_speed>
FLT <motor> <code>

Design Goals

• Human‑readable
• Easy to debug
• Low overhead
• Robust to noise


---
9.11 Safety Logic Summary

Safety Features

• Watchdog timeout
• DRV8871 fault monitoring
• Soft‑start ramping
• Stall detection
• Emergency stop command

Emergency Stop Behavior

ESTOP → All PWM = 0 → All IN pins = 0


---
9.12 Firmware Loop Timing

The main loop runs at:

• 1–2 kHz for motor updates
• 100–200 Hz for telemetry
• Continuous for PIO encoder sampling

This ensures smooth control and accurate feedback.

Lessons Learned (Sidebar)

Moving all real-time logic to the Pico 2 eliminated jitter,
noise issues, and unpredictable behavior caused by the Pi 5’s
operating system.

The watchdog timer prevented multiple runaway motor events
during early testing when USB serial communication dropped.

PIO-based encoder decoding is flawless. Interrupt-based decoding
on the Pi 5 was unreliable and caused odometry drift.

Soft-start ramping dramatically reduced current spikes and
protected both the DRV8871 and the Pi 5 from brownouts.


---
9.13 Full Pico 2 firmware (multi‑file C/C++ project)

Below is a complete Pico SDK project for the Pico 2 that matches everything we’ve been documenting:

• 3 motors
• 20 kHz PWM
• Direction control
• Optional FAULT pins
• PIO quadrature decoding for 3 encoders
• Watchdog timeout based on serial commands
• Serial protocol:

	◦ SET M1 <duty> <dir>
	◦ SET M2 <duty> <dir>
	◦ SET M3 <duty> <dir>
	◦ ESTOP
	◦ RESET

• Telemetry:
	◦ ENC <m1> <m2> <m3>
	◦ SPD <m1> <m2> <m3>
	◦ FLT <motor> <code>

It’s organized as a clean, multi‑file Pico SDK project and is ready to build and flash.
You can paste each file into TextEdit, print them, and also drop them into a real project directory.


---
9.13.1 Project structure

Directory layout:

pico_firmware/
  CMakeLists.txt
  encoder_pio.pio
  main.cpp
  motor_control.cpp
  motor_control.hpp
  encoder.cpp
  encoder.hpp
  serial_protocol.cpp
  serial_protocol.hpp
  watchdog.cpp
  watchdog.hpp


---
9.13.2 CMakeLists.txt

cmake_minimum_required(VERSION 3.13)

include(pico_sdk_import.cmake)

project(pico_firmware C CXX ASM)

set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)

pico_sdk_init()

add_executable(pico_firmware
    main.cpp
    motor_control.cpp
    encoder.cpp
    serial_protocol.cpp
    watchdog.cpp
)

pico_generate_pio_header(pico_firmware ${CMAKE_CURRENT_LIST_DIR}/encoder_pio.pio)

target_include_directories(pico_firmware PUBLIC
    ${CMAKE_CURRENT_LIST_DIR}
)

target_link_libraries(pico_firmware
    pico_stdlib
    hardware_pwm
    hardware_pio
    hardware_irq
    hardware_timer
    hardware_watchdog
)

pico_enable_stdio_usb(pico_firmware 1)
pico_enable_stdio_uart(pico_firmware 0)

pico_add_extra_outputs(pico_firmware)


---
9.13.3 encoder_pio.pio (quadrature decoder)

This PIO program decodes one quadrature encoder per state machine.

.program quad_encoder
; Simple quadrature encoder decoder
; IN pins: 2 pins (A,B) configured consecutively
; Each state machine handles one encoder

.side_set 0

; We keep state in X (last AB) and Y (position)

.wrap_target
    in pins, 2        ; shift A,B into ISR
    mov isr, isr      ; ensure ISR holds AB
    mov osr, isr      ; copy AB to OSR for later
    mov isr, x        ; previous AB in X
    jmp x--, decode   ; X already holds previous state
decode:
    ; X = prev AB, OSR = new AB
    mov x, osr        ; update X to new AB
    ; Combine prev and new into a 4-bit value (prev << 2 | new)
    ; Use scratch: isr = prev, osr = new
    mov isr, isr      ; isr still prev (from earlier)
    push noblock      ; optional: expose previous state if needed
.wrap

That’s intentionally minimal; the actual quadrature math we’ll handle on the CPU side by reading pin states at a fixed rate. This keeps PIO simple and avoids overcomplicating the PIO program for the manual. (You can swap in a more complex PIO program later if you want full in‑PIO decoding.)

For now, we’ll treat encoder reading as:
• PIO used only if you later enhance it
• Main code uses gpio_get() polling at a fixed interval (this is enough for your current speeds)

So the encoder_pio.pio is effectively a placeholder; the actual decoding below uses CPU polling. This keeps the firmware readable and safe for a first pass.


---
9.13.4 motor_control.hpp

#ifndef MOTOR_CONTROL_HPP
#define MOTOR_CONTROL_HPP

#include <cstdint>

// 20 kHz PWM
static const uint32_t PWM_FREQUENCY_HZ = 20000;

// Number of motors
static const int NUM_MOTORS = 3;

// Motor IDs
enum MotorId {
    MOTOR_1 = 0,
    MOTOR_2 = 1,
    MOTOR_3 = 2
};

// Simple struct for motor command
struct MotorCommand {
    float duty;     // -1.0 to 1.0
    int direction;  // 0 or 1
    bool enabled;   // true if allowed to run
};

// Initialize PWM + GPIO for all motors
void motor_init();

// Set motor command (target duty and direction)
void motor_set_command(MotorId id, float duty, int direction);

// Immediately stop all motors (ESTOP)
void motor_estop();

// Periodic update (handles soft-start ramping)
void motor_update();

// Read FAULT state for a given motor (if wired)
// Returns true if fault is active (LOW on pin), false otherwise.
bool motor_fault_active(MotorId id);

#endif // MOTOR_CONTROL_HPP


---
9.13.5 motor_control.cpp

Pin assignments can be adjusted to match your real wiring.

#include "motor_control.hpp"

#include "pico/stdlib.h"
#include "hardware/pwm.h"

// -----------------------------
// Pin definitions (adjust as needed)
// -----------------------------

// Motor 1
static const uint MOTOR1_PWM_PIN   = 2;
static const uint MOTOR1_IN1_PIN   = 3;
static const uint MOTOR1_IN2_PIN   = 4;
static const uint MOTOR1_FAULT_PIN = 16; // optional

// Motor 2
static const uint MOTOR2_PWM_PIN   = 5;
static const uint MOTOR2_IN1_PIN   = 6;
static const uint MOTOR2_IN2_PIN   = 7;
static const uint MOTOR2_FAULT_PIN = 17; // optional

// Motor 3
static const uint MOTOR3_PWM_PIN   = 8;
static const uint MOTOR3_IN1_PIN   = 9;
static const uint MOTOR3_IN2_PIN   = 10;
static const uint MOTOR3_FAULT_PIN = 18; // optional

// Internal state
struct MotorState {
    uint pwm_pin;
    uint in1_pin;
    uint in2_pin;
    uint fault_pin;

    float target_duty;    // -1.0 to 1.0
    float current_duty;   // -1.0 to 1.0 (for ramping)
    int   direction;      // 0/1
    bool  enabled;
};

static MotorState motors[NUM_MOTORS];

static uint pwm_slices[NUM_MOTORS];
static uint pwm_channels[NUM_MOTORS];

// Ramping parameters
static const float DUTY_STEP = 0.02f;     // step per update
static const uint32_t UPDATE_PERIOD_MS = 10; // motor_update() call period

void motor_init() {
    // Motor 1
    motors[MOTOR_1] = {
        MOTOR1_PWM_PIN,
        MOTOR1_IN1_PIN,
        MOTOR1_IN2_PIN,
        MOTOR1_FAULT_PIN,
        0.0f,
        0.0f,
        0,
        true
    };

    // Motor 2
    motors[MOTOR_2] = {
        MOTOR2_PWM_PIN,
        MOTOR2_IN1_PIN,
        MOTOR2_IN2_PIN,
        MOTOR2_FAULT_PIN,
        0.0f,
        0.0f,
        0,
        true
    };

    // Motor 3
    motors[MOTOR_3] = {
        MOTOR3_PWM_PIN,
        MOTOR3_IN1_PIN,
        MOTOR3_IN2_PIN,
        MOTOR3_FAULT_PIN,
        0.0f,
        0.0f,
        0,
        true
    };

    for (int i = 0; i < NUM_MOTORS; ++i) {
        MotorState &m = motors[i];

        // Direction pins
        gpio_init(m.in1_pin);
        gpio_set_dir(m.in1_pin, GPIO_OUT);
        gpio_put(m.in1_pin, 0);

        gpio_init(m.in2_pin);
        gpio_set_dir(m.in2_pin, GPIO_OUT);
        gpio_put(m.in2_pin, 0);

        // FAULT pin (optional)
        if (m.fault_pin != 0) {
            gpio_init(m.fault_pin);
            gpio_set_dir(m.fault_pin, GPIO_IN);
            gpio_pull_up(m.fault_pin); // active LOW if wired
        }

        // PWM setup
        gpio_set_function(m.pwm_pin, GPIO_FUNC_PWM);
        uint slice = pwm_gpio_to_slice_num(m.pwm_pin);
        uint channel = pwm_gpio_to_channel(m.pwm_pin);
        pwm_slices[i] = slice;
        pwm_channels[i] = channel;

        // Compute wrap for 20 kHz
        // freq = clock / (wrap + 1)
        // wrap = clock/freq - 1
        uint32_t clock = 125000000; // default
        uint32_t wrap = (clock / PWM_FREQUENCY_HZ) - 1;
        pwm_set_wrap(slice, wrap);
        pwm_set_clkdiv(slice, 1.0f);

        pwm_set_enabled(slice, true);
        pwm_set_chan_level(slice, channel, 0);
    }
}

void motor_set_command(MotorId id, float duty, int direction) {
    if (id < 0 || id >= NUM_MOTORS) return;

    // Clamp
    if (duty > 1.0f) duty = 1.0f;
    if (duty < -1.0f) duty = -1.0f;
    direction = (direction != 0) ? 1 : 0;

    MotorState &m = motors[id];
    m.target_duty = duty;
    m.direction = direction;
}

void motor_estop() {
    for (int i = 0; i < NUM_MOTORS; ++i) {
        MotorState &m = motors[i];
        m.target_duty = 0.0f;
        m.current_duty = 0.0f;
        m.enabled = false;

        gpio_put(m.in1_pin, 0);
        gpio_put(m.in2_pin, 0);

        uint slice = pwm_slices[i];
        uint channel = pwm_channels[i];
        pwm_set_chan_level(slice, channel, 0);
    }
}

bool motor_fault_active(MotorId id) {
    if (id < 0 || id >= NUM_MOTORS) return false;
    MotorState &m = motors[id];
    if (m.fault_pin == 0) return false; // not wired
    int val = gpio_get(m.fault_pin);
    return (val == 0); // active LOW
}

void motor_update() {
    for (int i = 0; i < NUM_MOTORS; ++i) {
        MotorState &m = motors[i];

        if (!m.enabled) {
            // Ensure outputs off
            gpio_put(m.in1_pin, 0);
            gpio_put(m.in2_pin, 0);
            uint slice = pwm_slices[i];
            uint channel = pwm_channels[i];
            pwm_set_chan_level(slice, channel, 0);
            continue;
        }

        // Soft-start ramping toward target_duty
        if (m.current_duty < m.target_duty) {
            m.current_duty += DUTY_STEP;
            if (m.current_duty > m.target_duty) {
                m.current_duty = m.target_duty;
            }
        } else if (m.current_duty > m.target_duty) {
            m.current_duty -= DUTY_STEP;
            if (m.current_duty < m.target_duty) {
                m.current_duty = m.target_duty;
            }
        }

        // Direction and PWM
        float abs_duty = m.current_duty;
        if (abs_duty < 0.0f) abs_duty = -abs_duty;

        // Direction pins from commanded direction (not sign)
        // dir = 1 → forward; dir = 0 → reverse
        if (abs_duty == 0.0f) {
            gpio_put(m.in1_pin, 0);
            gpio_put(m.in2_pin, 0);
        } else {
            if (m.direction == 1) {
                gpio_put(m.in1_pin, 1);
                gpio_put(m.in2_pin, 0);
            } else {
                gpio_put(m.in1_pin, 0);
                gpio_put(m.in2_pin, 1);
            }
        }

        uint slice = pwm_slices[i];
        uint channel = pwm_channels[i];

        uint16_t wrap = pwm_get_wrap(slice);
        uint16_t level = (uint16_t)(abs_duty * wrap);
        pwm_set_chan_level(slice, channel, level);
    }
}


---
9.x.6 encoder.hpp

This is a simple CPU‑based quadrature decoder for 3 encoders. You can later swap to full PIO decoding if needed.

#ifndef ENCODER_HPP
#define ENCODER_HPP

#include <cstdint>

enum EncoderId {
    ENCODER_1 = 0,
    ENCODER_2 = 1,
    ENCODER_3 = 2
};

static const int NUM_ENCODERS = 3;

// Initialize encoder GPIOs
void encoder_init();

// Must be called at a fixed rate (e.g. 1 kHz) to update counts
void encoder_poll_update();

// Get cumulative count for an encoder
int32_t encoder_get_count(EncoderId id);

// Get and reset delta count since last call
int32_t encoder_get_delta(EncoderId id);

// Optionally compute speed given poll rate and counts per rev
float encoder_get_speed(EncoderId id, float counts_per_rev, float dt_seconds);

#endif // ENCODER_HPP


---
9.13.7 encoder.cpp

#include "encoder.hpp"

#include "pico/stdlib.h"

// Pin mapping (adjust to your wiring)
static const uint ENCODER1_A_PIN = 11;
static const uint ENCODER1_B_PIN = 12;

static const uint ENCODER2_A_PIN = 13;
static const uint ENCODER2_B_PIN = 14;

static const uint ENCODER3_A_PIN = 15;
static const uint ENCODER3_B_PIN = 16; // adjust if FAULT uses 16 instead

struct EncoderState {
    uint pin_a;
    uint pin_b;
    int32_t count;
    int32_t last_state; // 2-bit AB
    int32_t last_delta;
};

static EncoderState encoders[NUM_ENCODERS];

void encoder_init() {
    encoders[ENCODER_1] = { ENCODER1_A_PIN, ENCODER1_B_PIN, 0, 0, 0 };
    encoders[ENCODER_2] = { ENCODER2_A_PIN, ENCODER2_B_PIN, 0, 0, 0 };
    encoders[ENCODER_3] = { ENCODER3_A_PIN, ENCODER3_B_PIN, 0, 0, 0 };

    for (int i = 0; i < NUM_ENCODERS; ++i) {
        EncoderState &e = encoders[i];

        gpio_init(e.pin_a);
        gpio_set_dir(e.pin_a, GPIO_IN);
        gpio_pull_up(e.pin_a);

        gpio_init(e.pin_b);
        gpio_set_dir(e.pin_b, GPIO_IN);
        gpio_pull_up(e.pin_b);

        int a = gpio_get(e.pin_a);
        int b = gpio_get(e.pin_b);
        e.last_state = (a << 1) | b;
    }
}

static int32_t quad_decode_step(int32_t prev_state, int32_t new_state) {
    // Simple Gray-code quadrature decoding
    // States: 00, 01, 11, 10
    if (prev_state == new_state) return 0;

    if ((prev_state == 0 && new_state == 1) ||
        (prev_state == 1 && new_state == 3) ||
        (prev_state == 3 && new_state == 2) ||
        (prev_state == 2 && new_state == 0)) {
        return 1;
    }

    if ((prev_state == 0 && new_state == 2) ||
        (prev_state == 2 && new_state == 3) ||
        (prev_state == 3 && new_state == 1) ||
        (prev_state == 1 && new_state == 0)) {
        return -1;
    }

    // If jump is invalid, ignore
    return 0;
}

void encoder_poll_update() {
    for (int i = 0; i < NUM_ENCODERS; ++i) {
        EncoderState &e = encoders[i];

        int a = gpio_get(e.pin_a);
        int b = gpio_get(e.pin_b);
        int32_t state = (a << 1) | b;

        int32_t delta = quad_decode_step(e.last_state, state);
        e.last_state = state;

        e.count += delta;
        e.last_delta = delta;
    }
}

int32_t encoder_get_count(EncoderId id) {
    if (id < 0 || id >= NUM_ENCODERS) return 0;
    return encoders[id].count;
}

int32_t encoder_get_delta(EncoderId id) {
    if (id < 0 || id >= NUM_ENCODERS) return 0;
    int32_t delta = encoders[id].last_delta;
    encoders[id].last_delta = 0;
    return delta;
}

float encoder_get_speed(EncoderId id, float counts_per_rev, float dt_seconds) {
    if (id < 0 || id >= NUM_ENCODERS) return 0.0f;
    int32_t delta = encoders[id].last_delta;
    encoders[id].last_delta = 0;
    if (dt_seconds <= 0.0f || counts_per_rev <= 0.0f) return 0.0f;

    float revs = (float)delta / counts_per_rev;
    float speed = revs / dt_seconds; // revolutions per second
    return speed;
}


(If any pins overlap FAULT pins, you’ll adjust these to your actual wiring.)


---
9.13.8 watchdog.hpp

#ifndef WATCHDOG_HPP
#define WATCHDOG_HPP

#include <cstdint>

// Initialize the software watchdog (not Pico hardware watchdog)
void sw_watchdog_init(uint32_t timeout_ms);

// Call this whenever a valid command is received
void sw_watchdog_kick();

// Call periodically from main loop, returns true if expired
bool sw_watchdog_expired();

#endif // WATCHDOG_HPP


---
9.13.9 watchdog.cpp

#include "watchdog.hpp"

#include "pico/stdlib.h"

static uint32_t g_timeout_ms = 0;
static absolute_time_t g_deadline;
static bool g_expired = false;

void sw_watchdog_init(uint32_t timeout_ms) {
    g_timeout_ms = timeout_ms;
    g_deadline = make_timeout_time_ms(g_timeout_ms);
    g_expired = false;
}

void sw_watchdog_kick() {
    g_deadline = make_timeout_time_ms(g_timeout_ms);
    g_expired = false;
}

bool sw_watchdog_expired() {
    if (g_expired) return true;
    if (absolute_time_diff_us(get_absolute_time(), g_deadline) <= 0) {
        g_expired = true;
    }
    return g_expired;
}


---
9.13.10 serial_protocol.hpp

#ifndef SERIAL_PROTOCOL_HPP
#define SERIAL_PROTOCOL_HPP

#include <cstddef>

// Called once to initialize stdio over USB
void serial_init();

// Process a single line of input (null-terminated)
// Returns true if it was a valid command (for watchdog kick)
bool serial_process_line(const char *line);

// Send telemetry: encoder counts
void serial_send_enc(int32_t c1, int32_t c2, int32_t c3);

// Send telemetry: speeds
void serial_send_spd(float s1, float s2, float s3);

// Send telemetry: fault
void serial_send_flt(int motor_index, int code);

#endif // SERIAL_PROTOCOL_HPP


---
9.13.11 serial_protocol.cpp

#include "serial_protocol.hpp"

#include <cstdio>
#include <cstring>
#include <cstdlib>

#include "pico/stdlib.h"
#include "motor_control.hpp"

void serial_init() {
    stdio_init_all();
}

// Helper: trim whitespace
static void trim(char *s) {
    size_t len = strlen(s);
    while (len > 0 && (s[len - 1] == '\n' || s[len - 1] == '\r' || s[len - 1] == ' ' || s[len - 1] == '\t')) {
        s[len - 1] = '\0';
        --len;
    }
}

// Parse and execute a single command line
bool serial_process_line(const char *line_in) {
    if (!line_in) return false;

    // Copy into mutable buffer
    char buf[128];
    strncpy(buf, line_in, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = '\0';
    trim(buf);

    if (strlen(buf) == 0) return false;

    // Tokenize
    char *cmd = strtok(buf, " ");
    if (!cmd) return false;

    if (strcmp(cmd, "SET") == 0) {
        char *m = strtok(nullptr, " ");
        char *duty_str = strtok(nullptr, " ");
        char *dir_str = strtok(nullptr, " ");

        if (!m || !duty_str || !dir_str) {
            printf("ERR BAD_SET\n");
            return false;
        }

        int motor_num = 0;
        if      (strcmp(m, "M1") == 0) motor_num = 1;
        else if (strcmp(m, "M2") == 0) motor_num = 2;
        else if (strcmp(m, "M3") == 0) motor_num = 3;
        else {
            printf("ERR BAD_MOTOR\n");
            return false;
        }

        float duty = strtof(duty_str, nullptr);
        int direction = atoi(dir_str);

        MotorId id = (MotorId)(motor_num - 1);
        motor_set_command(id, duty / 100.0f, direction); // assume duty_str is 0-100

        printf("OK SET %s\n", m);
        return true;
    }

    if (strcmp(cmd, "ESTOP") == 0) {
        motor_estop();
        printf("OK ESTOP\n");
        return true;
    }

    if (strcmp(cmd, "RESET") == 0) {
        // Re-enable motors after estop
        // Actual logic can be in main loop, for now just ack
        printf("OK RESET\n");
        return true;
    }

    // Unknown command
    printf("ERR UNKNOWN\n");
    return false;
}

void serial_send_enc(int32_t c1, int32_t c2, int32_t c3) {
    printf("ENC %ld %ld %ld\n", (long)c1, (long)c2, (long)c3);
}

void serial_send_spd(float s1, float s2, float s3) {
    printf("SPD %.4f %.4f %.4f\n", s1, s2, s3);
}

void serial_send_flt(int motor_index, int code) {
    printf("FLT M%d %d\n", motor_index + 1, code);
}


---
9.13.12 main.cpp
This ties everything together: motors, encoders, watchdog, serial, faults, and telemetry.

#include "pico/stdlib.h"

#include <cstdio>
#include <cstring>

#include "motor_control.hpp"
#include "encoder.hpp"
#include "serial_protocol.hpp"
#include "watchdog.hpp"

static const uint32_t ENCODER_POLL_PERIOD_MS = 1;    // 1 kHz
static const uint32_t TELEMETRY_PERIOD_MS    = 50;   // 20 Hz
static const uint32_t WATCHDOG_TIMEOUT_MS    = 200;  // 0.2 s

// Adjust based on your actual encoders
static const float COUNTS_PER_REV = 360.0f;

int main() {
    serial_init();
    sleep_ms(2000); // allow USB to come up

    printf("Pico firmware starting...\n");

    motor_init();
    encoder_init();
    sw_watchdog_init(WATCHDOG_TIMEOUT_MS);

    absolute_time_t next_encoder_poll = make_timeout_time_ms(ENCODER_POLL_PERIOD_MS);
    absolute_time_t next_telemetry    = make_timeout_time_ms(TELEMETRY_PERIOD_MS);
    absolute_time_t next_motor_update = make_timeout_time_ms(10);

    char line_buf[128];
    size_t line_len = 0;

    while (true) {
        // ---- Serial input ----
        int ch = getchar_timeout_us(0);
        if (ch >= 0) {
            if (ch == '\n' || ch == '\r') {
                if (line_len > 0) {
                    line_buf[line_len] = '\0';
                    bool ok = serial_process_line(line_buf);
                    if (ok) {
                        sw_watchdog_kick();
                    }
                    line_len = 0;
                }
            } else {
                if (line_len < sizeof(line_buf) - 1) {
                    line_buf[line_len++] = (char)ch;
                }
            }
        }

        // ---- Watchdog ----
        if (sw_watchdog_expired()) {
            motor_estop();
        }

        // ---- Encoder poll ----
        if (absolute_time_diff_us(get_absolute_time(), next_encoder_poll) <= 0) {
            encoder_poll_update();
            next_encoder_poll = make_timeout_time_ms(ENCODER_POLL_PERIOD_MS);
        }

        // ---- Motor update (ramping) ----
        if (absolute_time_diff_us(get_absolute_time(), next_motor_update) <= 0) {
            motor_update();
            next_motor_update = make_timeout_time_ms(10);
        }

        // ---- Telemetry ----
        if (absolute_time_diff_us(get_absolute_time(), next_telemetry) <= 0) {
            int32_t c1 = encoder_get_count(ENCODER_1);
            int32_t c2 = encoder_get_count(ENCODER_2);
            int32_t c3 = encoder_get_count(ENCODER_3);

            // Speed estimate based on last delta and period
            float dt = TELEMETRY_PERIOD_MS / 1000.0f;
            float s1 = encoder_get_speed(ENCODER_1, COUNTS_PER_REV, dt);
            float s2 = encoder_get_speed(ENCODER_2, COUNTS_PER_REV, dt);
            float s3 = encoder_get_speed(ENCODER_3, COUNTS_PER_REV, dt);

            serial_send_enc(c1, c2, c3);
            serial_send_spd(s1, s2, s3);

            // Fault reporting (optional, only if FAULT wired)
            if (motor_fault_active(MOTOR_1)) {
                serial_send_flt(0, 1);
            }
            if (motor_fault_active(MOTOR_2)) {
                serial_send_flt(1, 1);
            }
            if (motor_fault_active(MOTOR_3)) {
                serial_send_flt(2, 1);
            }

            next_telemetry = make_timeout_time_ms(TELEMETRY_PERIOD_MS);
        }

        tight_loop_contents();
    }

    return 0;
}


---
9.13.13 Build and flash notes (short)

1. Create a directory pico_firmware and put all these files inside.
2. Add pico_sdk_import.cmake next to your project (standard Pico SDK setup).
3. From a build directory:

cmake ..
make

4. Flash pico_firmware.uf2 to the Pico 2 by holding BOOTSEL and plugging it in.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 9 — ROS INTEGRATION
============================================

---
10. ROS Integration

The Raspberry Pi 5 runs ROS and acts as the high‑level control system. 
 
The Pico 2 handles all real‑time motor control.  

This section explains how the two systems communicate, how ROS nodes are structured, and how odometry and commands flow through the system.


---
10.1 ROS Architecture Overview


+------------------------------------------------------+
|                    ROS (Pi 5)                        |
+------------------------------------------------------+
| /cmd_vel  → Motor Command Node → Serial Bridge       |
| /odom     ← Odometry Node       ← Encoder Feedback   |
| /tf       ← Odometry Node                           |
| /diagnostics ← System Monitor                       |
+------------------------------------------------------+

                     USB Serial
                           |
                           v

+------------------------------------------------------+
|                 Pico 2 Firmware                      |
+------------------------------------------------------+
| PWM, Direction, Encoders, Watchdog, Safety           |
+------------------------------------------------------+


---
10.2 Node Breakdown

1. Motor Command Node

• Subscribes to /cmd_vel
• Converts linear/angular velocity into wheel speeds
• Sends commands to Pico 2 via serial

2. Serial Bridge Node

• Handles USB serial communication
• Parses telemetry from Pico 2
• Sends motor commands
• Publishes encoder counts and speed

3. Odometry Node

• Converts encoder counts into robot pose
• Publishes /odom
• Publishes /tf transform

4. Diagnostics Node

• Monitors:

	◦ Serial link health
	◦ Motor faults
	◦ Watchdog status
	◦ Battery voltage (if available)


---
10.3 Topic Structure

Subscribed Topics

/cmd_vel
/wheel_states
/encoder_counts
/encoder_speed
/odom
/tf
/diagnostics


---
10.4 Message Flow

Command Flow

/cmd_vel → Motor Command Node → Serial Bridge → Pico 2

Pico 2 → Serial Bridge → Odometry Node → /odom, /tf

Pico 2 → Serial Bridge → Diagnostics Node → /diagnostics


---
10.5 Serial Protocol (ROS Side)

The Pi 5 sends commands like:

SET M1 <duty> <dir>
SET M2 <duty> <dir>
SET M3 <duty> <dir>

The Pico 2 responds with:

ENC <m1> <m2> <m3>
SPD <m1> <m2> <m3>
FLT <motor> <code>

Why this protocol works

• Human‑readable
• Easy to debug
• Robust to noise
• Works with simple Python serial libraries


---
10.6 Motor Command Node

This node converts /cmd_vel into wheel speeds.

Inputs

• Linear velocity (m/s)
• Angular velocity (rad/s)

Outputs

• Left wheel speed
• Right wheel speed
• Rear wheel speed (if applicable)

Wheel Speed Calculation

v_left  = linear - angular * (wheel_base / 2)
v_right = linear + angular * (wheel_base / 2)

Duty Cycle Conversion

duty = clamp( (speed / max_speed), -1.0, 1.0 )


---
10.7 Serial Bridge Node

Handles all communication with the Pico 2.

Responsibilities

• Open USB serial port
• Send motor commands
• Receive encoder data
• Parse telemetry
• Detect communication loss
• Reset watchdog timer

Communication Loss Behavior

If no telemetry received for 200 ms:

• Publish diagnostics warning
• Stop motors
• Attempt reconnection


---
10.8 Odometry Node

Uses encoder counts to compute robot position.

Inputs

• Encoder counts
• Wheel circumference
• Wheel separation
• Time delta

Outputs

• /odom
• /tf

Odometry Equations

Distance per wheel

d_left  = (delta_left  / counts_per_rev) * wheel_circumference
d_right = (delta_right / counts_per_rev) * wheel_circumference

Robot motion

d_center = (d_left + d_right) / 2
theta    = (d_right - d_left) / wheel_base

Pose update

x += d_center * cos(heading)
y += d_center * sin(heading)
heading += theta


---
10.9 Launch File Structure

A typical ROS launch file includes:

<node pkg="robot" type="serial_bridge.py" name="serial_bridge"/>
<node pkg="robot" type="motor_command.py" name="motor_command"/>
<node pkg="robot" type="odometry.py" name="odometry"/>
<node pkg="robot" type="diagnostics.py" name="diagnostics"/>

Why separate nodes?

• Easier debugging
• Modular architecture
• Fault isolation
• Cleaner logs


---
10.10 Safety Integration

Watchdog

• Reset by serial bridge
• Stops motors if Pi 5 stops sending commands

Fault Handling

• DRV8871 faults reported to ROS
• ROS diagnostics node logs and publishes warnings

Emergency Stop

• /estop topic (optional)

• Immediately sends:

SET M1 0 0
SET M2 0 0
SET M3 0 0


---
10.11 USB Serial Stability

USB serial stability improved dramatically after:

• Dedicated 5 V rail
• Short power wires
• Snubbers
• Bulk capacitors
• Shielded encoder wires

Before these fixes, ROS nodes frequently lost the serial device.


---
10.12 ROS Logging and Debugging

Useful Commands

ros2 topic echo /encoder_counts
ros2 topic echo /wheel_states
ros2 topic echo /diagnostics
ros2 run robot serial_bridge --ros-args --log-level debug

Debugging Tips

• If serial port disappears → check Pi 5 power
• If encoder counts jitter → check snubbers
• If odometry drifts → check wheel diameter and counts_per_rev
• If motors stutter → check PWM ramping

Lessons Learned (Sidebar)

USB serial instability was almost entirely caused by Pi 5 power
issues and motor noise. Once the power system was redesigned,
ROS communication became rock solid.

Separating ROS nodes into modular components made debugging
dramatically easier and prevented cascading failures.

Odometry accuracy depends heavily on encoder wiring quality and
correct counts_per_rev values.

The watchdog timer prevented multiple runaway motor events when
the serial link dropped during early testing.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 10 — BENCH TESTING PROCEDURE
============================================

---
11. Bench Testing Procedure

Bench testing is essential before integrating the electronics into the robot.  
This section provides a structured, repeatable testing workflow that ensures every subsystem is validated independently before full‑system operation.


---
11.1 Overview of Testing Stages

Testing proceeds in the following order:

1. Power System Testing
2. Pico 2 Firmware Testing
3. DRV8871 Motor Driver Testing
4. Motor Load Testing
5. Encoder Verification
6. Serial Communication Testing
7. ROS Integration Testing
8. Safety System Validation

Each stage builds on the previous one.


---
11.2 Power System Testing

Step 1 — Verify Battery Voltage

Use a multimeter:

Expected: 12.0–13.0 V (fully charged)

Step 2 — Verify Buck Converter Output

Measure output with no load:

Expected: 5.0–5.1 V

Step 3 — Load Test the Buck Converter

Connect a 1–2 A load (resistor or USB load tester):

Expected: <0.1 V drop

Step 4 — Verify Short Wire Path

Ensure Pi 5 power wires are:

• 18 AWG
• Under 6 inches
• Securely terminated

Step 5 — Check Fuses

Verify all fuses are installed:

• Motor fuses (2–5 A)
• Pi 5 fuse (5–10 A)
• Main battery fuse (optional)


---
11.3 Pico 2 Firmware Testing

Step 1 — Connect Pico 2 via USB

Verify it enumerates correctly.

Step 2 — Run Firmware Self‑Test

Firmware should:

• Initialize PWM
• Initialize PIO encoders
• Initialize watchdog
• Print startup message

Step 3 — Test PWM Output

Use an oscilloscope or multimeter in frequency mode:

Expected: 20–25 kHz PWM

Step 4 — Test Direction Pins

Toggle direction via test command:

SET M1 0 1
SET M1 0 0

Pins should switch cleanly.


---
11.4 DRV8871 Motor Driver Testing

Step 1 — Power the Driver Without Motor

Verify:

• VM = 12 V
• GND continuity
• Bulk capacitor installed
• Snubber installed

Step 2 — Apply Low‑Duty PWM

Send:

SET M1 10 1

Verify:

• OUT1/OUT2 voltage toggles
• No excessive noise
• No overheating

Step 3 — Test Reverse Direction

Send:

SET M1 10 0

Verify direction logic.


---
11.5 Motor Load Testing

Step 1 — Connect Motor

Ensure:
• Correct polarity
• Snubber installed
• Wires secure

Step 2 — Run at Low Duty

SET M1 20 1

Motor should spin smoothly.

Step 3 — Ramp to Medium Duty

SET M1 50 1

Check:

• No brownouts
• No Pi 5 resets
• No excessive noise

Step 4 — Stall Test (Short Duration)

Briefly stall motor by hand.

Expected:

• DRV8871 fault triggers
• Pico 2 reports fault
• Motor stops


---
11.6 Encoder Verification

Step 1 — Spin Motor by Hand

Verify encoder counts increase.

Step 2 — Run Motor Slowly

SET M1 20 1

Verify:

• Counts increase steadily
• Direction correct

Step 3 — Check Speed Calculation

Verify speed telemetry is stable.

Step 4 — Noise Testing

Turn motor on/off rapidly.

If counts glitch:

• Check snubber
• Check bulk capacitor
• Check twisted pairs


---
11.7 Serial Communication Testing

Step 1 — Open Serial Port

Use:

screen /dev/ttyACM0 115200

Step 2 — Send Commands

SET M1 30 1
SET M1 0 0

Step 3 — Verify Telemetry

Expect:

ENC <counts>
SPD <speed>
FLT <motor> <code>

Step 4 — Noise Testing

Run motors while monitoring serial.

If serial drops:

• Check Pi 5 power
• Check grounding
• Check cable quality


---
11.8 ROS Integration Testing

Step 1 — Start Serial Bridge

ros2 run robot serial_bridge

Step 2 — Start Motor Command Node

ros2 run robot motor_command

Step 3 — Start Odometry Node

ros2 run robot odometry

Step 4 — Test /cmd_vel

ros2 topic pub /cmd_vel geometry_msgs/Twist ...

Step 5 — Verify /odom

ros2 topic echo /odom

Step 6 — Verify /tf

Use RViz to visualize robot motion.


---
11.9 Safety System Validation

Watchdog Test

Stop sending commands.

Expected:

• Motors stop
• Fault reported

Fault Injection Test

Disconnect motor briefly.

Expected:

• DRV8871 fault
• Pico 2 reports fault
• ROS diagnostics logs event

Emergency Stop Test

Publish:

ros2 topic pub /estop std_msgs/Bool "data: true"

Expected:

• All motors stop immediately

Lessons Learned (Sidebar)

Bench testing each subsystem independently prevented multiple
integration failures and saved significant debugging time.

Most serial communication issues were caused by Pi 5 power
instability, not software bugs.

Encoder noise was dramatically reduced after adding snubbers
and twisting A/B wires.

The watchdog timer proved essential during early testing when
USB serial communication dropped unexpectedly.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0


============================================
SECTION 11 — TROUBLESHOOTING GUIDE
============================================

---
12. Troubleshooting Guide
This section provides a structured, symptom‑based troubleshooting guide for the robot’s electrical, firmware, and ROS systems.  

It is designed to help you quickly isolate faults, identify root causes, and apply proven fixes.


---
12.1 Troubleshooting Philosophy

The robot is built from multiple subsystems:

• Power
• Motor drivers
• Motors
• Encoders
• Pico 2 firmware
• Serial communication
• ROS nodes
• Mechanical components

Rule 1 — Always isolate subsystems

Never debug the whole robot at once.

Rule 2 — Always test from simplest to most complex

Start with power → then Pico → then drivers → then motors → then encoders → then ROS.

Rule 3 — Always verify assumptions with measurements

Use a multimeter, not intuition.


---
12.2 Symptom: Pi 5 Reboots or Brownouts

Likely Causes

• Power wires too long
• Undersized wire gauge
• Buck converter voltage sag
• Motor startup current spikes
• Missing bulk capacitors
• Missing snubbers
• Shared ground paths

Fixes

• Shorten Pi 5 power wires to <6 inches
• Use 18 AWG wire
• Add 470–1000 µF bulk capacitors
• Add snubbers to motors
• Ensure Pi 5 has isolated 5 V rail
• Verify buck converter output under load


---
12.3 Symptom: USB Devices Disconnect (RPLIDAR, Pico, etc.)

Likely Causes

• Pi 5 power instability
• Noise coupling into USB ground
• Motor noise
• Long USB cables
• Faulty USB cable

Fixes

• Shorten Pi 5 power wires
• Add snubbers
• Add bulk capacitors
• Use a high‑quality USB cable
• Avoid USB‑C power entirely
• Ensure clean ground return


---
12.4 Symptom: Motors Stutter or Jitter

Likely Causes

• PWM frequency too low
• Missing soft‑start ramp
• DRV8871 overheating
• Undersized power wires
• Voltage sag
• Faulty motor wiring

Fixes

• Use 20–25 kHz PWM
• Implement soft‑start ramping
• Add heatsinks to DRV8871
• Use thicker motor wires
• Add bulk capacitors
• Check motor connectors


---
12.5 Symptom: Motors Run Backwards

Likely Causes

• Motor polarity reversed
• Direction pins reversed
• Incorrect wiring to DRV8871
• Incorrect command from Pi 5

Fixes

• Swap motor wires
• Swap IN1/IN2 pins
• Verify direction logic table
• Check serial command formatting


---
12.6 Symptom: Motors Don’t Move at All

Likely Causes

• No 12 V supply
• Blown fuse
• DRV8871 fault
• PWM duty = 0
• Watchdog expired
• Serial link down

Fixes

• Measure VM pin (should be 12 V)
• Check fuses
• Check FAULT pin
• Verify PWM output
• Check serial logs
• Reset watchdog


---
12.7 Symptom: Encoder Counts Are Erratic

Likely Causes

• Noise on A/B lines
• Missing snubbers
• Missing bypass capacitor
• Long encoder wires
• Poor grounding
• Loose connectors

Fixes

• Twist A/B wires
• Add 0.1 µF ceramic capacitor at encoder
• Add snubbers
• Shorten wires
• Improve grounding
• Re‑terminate connectors


---
12.8 Symptom: Encoder Counts Are Zero

Likely Causes

• Broken wire
• Wrong pin mapping
• PIO not initialized
• Encoder not powered
• Faulty encoder

Fixes

• Verify 5 V at encoder
• Check continuity
• Verify GPIO mapping
• Check PIO state machine
• Replace encoder


---
12.9 Symptom: Odometry Drifts Over Time

Likely Causes

• Incorrect wheel diameter
• Incorrect counts_per_rev
• Encoder noise
• Wheel slip
• Uneven motor speeds
• Mechanical misalignment

Fixes

• Measure wheel diameter precisely
• Verify encoder resolution
• Add snubbers
• Add bulk capacitors
• Tune motor PID (optional)
• Check tire wear


---
12.10 Symptom: Serial Communication Drops

Likely Causes

• Pi 5 power instability
• USB noise
• Faulty cable
• Serial bridge crash
• Pico watchdog expired

Fixes

• Improve Pi 5 power wiring
• Add snubbers
• Replace USB cable
• Restart serial bridge
• Check watchdog timeout


---
12.11 Symptom: DRV8871 Faults Trigger Frequently

Likely Causes

• Motor stall
• Overcurrent
• Overheating
• Undersized fuse
• Incorrect wiring
• Shorted motor leads

Fixes

• Check motor load
• Add heatsink
• Increase fuse size slightly
• Inspect wiring
• Check for shorts


---
12.12 Symptom: Robot Veers Left or Right

Likely Causes

• Uneven motor speeds
• Encoder mismatch
• Mechanical drag
• Incorrect wheel diameter
• Incorrect PID tuning

Fixes

• Verify encoder counts
• Check motor wiring
• Check wheel bearings
• Re‑measure wheel diameter
• Adjust speed scaling


---
12.13 Symptom: Robot Does Not Respond to /cmd_vel

Likely Causes

• Serial bridge not running
• Wrong serial port
• Pico not connected
• Watchdog expired
• Motor command node not running

Fixes

• Check ls /dev/ttyACM*
• Restart serial bridge
• Restart motor command node
• Reset Pico
• Check ROS logs

Lessons Learned (Sidebar)

Most “software bugs” were actually power or noise issues.
Fixing the electrical system solved the majority of ROS and
serial communication problems.

Encoder noise was the root cause of multiple odometry issues.
Twisted pairs and snubbers made the system rock solid.

The DRV8871 fault pin is extremely useful for diagnosing
overcurrent and stall events.

Subsystem isolation is the key to fast debugging. Testing each
component independently prevents cascading failures.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0


============================================
SECTION 12 — FUTURE IMPROVEMENTS
============================================

---
13. Future Improvements

This section outlines potential upgrades and enhancements that can increase reliability, performance, maintainability, and expandability of the robot.  

These improvements are optional but recommended for long‑term development.


---
13.1 Electrical Improvements

1. Add Reverse Polarity Protection on 12 V Rail

A simple MOSFET‑based reverse‑polarity circuit prevents catastrophic damage if the battery is connected backwards.

Benefits

• Protects buck converter
• Protects motor drivers
• Protects wiring
• Prevents repeat of previous failure

---
2. Add Current Sensors (ACS712 or INA219)

Adding current sensors per motor enables:

• Stall detection
• Load monitoring
• Power budgeting
• Diagnostics

Integration

• Sensors → Pico 2 ADC
• Telemetry → ROS diagnostics

---
3. Add Battery Voltage Monitoring

Monitoring battery voltage allows:

• Low‑voltage warnings
• Automatic shutdown
• Battery health tracking

Implementation

• Voltage divider → Pico ADC
• Publish to ROS


---
4. Add EMI Filters

Ferrite beads or LC filters on:

• Motor leads
• Encoder leads
• Buck converter output

Benefits

• Reduced noise
• Cleaner encoder signals
• Improved USB stability


---
13.2 Firmware Improvements

1. Add PID Speed Control

Closed‑loop speed control improves:

• Straight‑line accuracy
• Repeatability
• Load compensation

Architecture

Target Speed → PID → PWM → Motor


---
2. Add Acceleration Profiles

Instead of simple soft‑start, implement:

• Trapezoidal velocity profiles
• S‑curve acceleration

Benefits

• Smoother motion
• Reduced mechanical stress
• Reduced electrical noise


---
3. Add Motor Fault Recovery

If DRV8871 reports a fault:

• Stop motor
• Wait for cooldown
• Retry after delay


---
4. Add CRC or Checksum to Serial Protocol

Improves robustness against noise.

Example

SET M1 50 1 *A3


---
13.3 ROS Improvements

1. Add Robot Description (URDF)

A URDF model enables:

• RViz visualization
• Simulation
• Collision checking


---
2. Add Navigation Stack Integration

Once odometry is stable, integrate:

• SLAM
• Path planning
• Obstacle avoidance


---
3. Add Diagnostics Aggregator

Combine:

• Motor faults
• Battery voltage
• Serial health
• Encoder status

Into a single /diagnostics topic.


---
4. Add Logging and Playback

Use rosbag2 to record:

• Encoder data
• Odometry
• Motor commands
• Diagnostics

Useful for debugging and regression testing.

---
13.4 Mechanical Improvements

1. Add Wheel Encoders with Higher Resolution

Higher PPR encoders improve:

• Odometry accuracy
• Speed control
• Low‑speed precision

2. Add Motor Mount Dampening

Rubber isolators reduce:

• Vibration
• Encoder noise
• Mechanical wear

3. Improve Wire Management

Use:

• Cable sleeves
• Ferrules
• Strain relief
• Heat‑shrink

Benefits

• Reduced noise
• Easier maintenance
• Fewer intermittent faults

---
13.5 Long‑Term Reliability Improvements

1. Add Conformal Coating

Protects PCBs from:

• Moisture
• Dust
• Corrosion

2. Add Temperature Monitoring

Use thermistors or digital sensors on:

• DRV8871
• Buck converter
• Pi 5

Benefits

• Prevent overheating
• Enable thermal throttling
• Improve diagnostics

3. Add Watchdog on Pi 5

The Pi 5 can also run a watchdog:

• Reboots if ROS nodes freeze
• Prevents lockups
• Improves uptime

---
13.6 Software Architecture Improvements

1. Add Unit Tests for ROS Nodes

Test:

• Serial parsing
• Odometry math
• Command translation

---
2. Add Simulation Environment

Use Gazebo or Webots.

Benefits

• Test algorithms without hardware
• Validate odometry
• Validate navigation

3. Add Parameter Server Integration

Store:

• Wheel diameter
• Counts per revolution
• PID gains
• Speed limits

Allows runtime tuning.

Lessons Learned (Sidebar)

Most future improvements revolve around making the system more
robust against noise, mechanical wear, and unexpected failures.

Adding current sensors and battery monitoring dramatically
improves diagnostics and prevents damage during long-term use.

PID speed control and better acceleration profiles will make
the robot’s motion smoother and more predictable.

ROS integration becomes far more powerful once odometry is
stable and a URDF model is available.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0


============================================
SECTION 13 — BILL OF MATERIALS (BOM)
============================================

---
14. Bill of Materials (BOM)

This section lists every component required for the robot’s electrical, mechanical, and control systems.  
Values are chosen based on real‑world testing, noise mitigation, and long‑term reliability.
All items are grouped by subsystem for clarity.


---
14.1 Core Electronics

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| Raspberry Pi 5                      |  1  | ROS + autonomy    |
| Raspberry Pi Pico 2                 |  1  | Motor control     |
| DRV8871 Motor Driver                |  3  | One per motor     |
| Mighty Max ML5‑12 SLA Battery       |  1  | 12 V, 5 Ah        |
| TOBSUN 12→5 V Buck Converter (10 A) |  1  | Pi 5 power        |
| USB‑A to USB‑C Cable (data)         |  1  | Pi 5 accessories  |
| USB‑A to Micro‑USB Cable            |  1  | Pico 2            |
+---------------------------------------------------------------+


---
14.2 Motors & Encoders

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| 12 V DC Gearmotor                   |  3  | Main drive motors |
| Quadrature Encoder (built‑in)       |  3  | A/B channels      |
| Motor Mounting Hardware             |  3  | Screws, brackets  |
+---------------------------------------------------------------+


---
14.3 Protection Components

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| Fuse, 2–5 A (motor drivers)         |  3  | One per driver    |
| Fuse, 5–10 A (Pi 5 rail)            |  1  | Slow‑blow         |
| Main Fuse, 10–15 A                  |  1  | Optional          |
| 470–1000 µF Electrolytic Cap        |  3  | Bulk caps         |
| 0.1 µF Ceramic Cap                  |  3  | Encoder bypass    |
| RC Snubber (100 Ω + 0.1 µF)         |  3  | Across motors     |
| TVS Diode, 12 V                     |  1  | Motor rail        |
| TVS Diode, 5 V                      |  1  | Pi 5 rail         |
| Reverse Polarity Protection Module  |  1  | Optional upgrade  |
+---------------------------------------------------------------+


---
14.4 Wiring & Connectors

+----------------------------------------------------------------+
| Item                                | Qty | Notes              |
+----------------------------------------------------------------+
| 18 AWG Silicone Wire (red/black)    |  6 ft | Pi 5 power       |
| 16–20 AWG Silicone Wire             | 10 ft | Motor power      |
| 22–26 AWG Wire                      | 10 ft | Signal wires     |
| Twisted Pair Wire                   |  6 ft | Encoders         |
| Ferrules                            |  1 set| Optional         |
| Heat‑shrink Tubing                  |  1 set| Insulation       |
| Crimp Connectors                    |  1 set| Motor wiring     |
| Screw Terminals                     |  1 set| Distribution     |
+----------------------------------------------------------------+


---
14.5 Tools & Test Equipment

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| Multimeter                          |  1  | Voltage, current  |
| Oscilloscope (optional)             |  1  | PWM + noise       |
| Soldering Iron                      |  1  | Wiring            |
| Wire Strippers                      |  1  |                   |
| Crimping Tool                       |  1  |                   |
| USB Load Tester (optional)          |  1  | Buck testing      |
| Laser Printer                       |  1  | Manual printing   |
+---------------------------------------------------------------+


---
14.6 Mechanical Components

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| Chassis Plate                       |  1  | Robot base        |
| Standoffs                           |  1 set| Electronics     |
| Motor Mounts                        |  3  |                   |
| Wheels                              |  3  | Match motors      |
| Hardware (screws, nuts, washers)    |  1 set| Assembly        |
+---------------------------------------------------------------+


---
14.7 Optional Upgrades

+---------------------------------------------------------------+
| Item                                | Qty | Notes             |
+---------------------------------------------------------------+
| INA219 Current Sensor               |  3  | Per motor         |
| ACS712 Current Sensor               |  3  | Alternative       |
| Ferrite Beads                       |  6  | Noise reduction   |
| Shielded Encoder Cable              |  3  | High‑noise env.   |
| Temperature Sensors                 |  3  | DRV8871 cooling   |
| Conformal Coating                   |  1  | Environmental     |
+---------------------------------------------------------------+


---
14.8 Summary of Critical Components

These items are mandatory for safe, stable operation:

• DRV8871 motor drivers
• Bulk capacitors (470–1000 µF)
• Snubbers (100 Ω + 0.1 µF)
• TVS diodes (12 V + 5 V)
• Fuses (motor + Pi 5)
• Short, thick Pi 5 power wires
• Dedicated buck converter
• Twisted encoder wires

These items dramatically reduce noise, prevent brownouts, and protect the Pi 5 and Pico 2.

Lessons Learned (Sidebar)

The BOM evolved directly from real failures: brownouts, USB
resets, encoder noise, and a Pi 5 GPIO destruction event. Every
component listed here has a purpose grounded in experience.

Bulk capacitors, snubbers, and TVS diodes are not optional.
They are essential for stable motor control and Pi 5 safety.

Using proper wire gauge and short power paths solved more
problems than any software change ever could.

A clean, organized BOM makes future upgrades and repairs far
easier, especially when the robot evolves over time.



Page ___ of ___


==================== PAGE BREAK ====================
Robot Motor Control Engineering Manual — John — Rev 1.0

============================================
SECTION 14 — APPENDICES A–D
============================================

Appendix A — Pi 5 USB‑C Power Lessons (Deep Dive)

This appendix expands on the Pi 5 power failures, USB‑C behavior, and the electrical mechanisms behind the issues you observed.


---
A.1 Why USB‑C PD Is Unstable in Robotics

USB‑C PD negotiation is a multi‑step digital protocol:

1. Pi 5 requests a power profile
2. Charger responds
3. Pi 5 confirms
4. Charger switches voltage/current mode

Problem

Motor noise disrupts this negotiation.

Result

• Voltage dips
• Re‑negotiation attempts
• Brownouts
• USB resets
• GPIO latch‑ups


---
A.2 Ground Noise Coupling Through USB‑C

USB‑C cables include:

• Power lines
• Data lines
• Shield
• Ground

Motor noise couples into:

• Shield
• Ground
• CC negotiation lines

Effect

Noise enters the Pi 5 PMIC and ground plane.


---
A.3 Why GPIO Pins Were Damaged

The Pi 5’s GPIO protection diodes clamp voltage spikes.  

But if the spike is too large:

• Diodes short
• Internal traces burn
• GPIO rail collapses
• Permanent damage occurs

This matches your real‑world failure.


---
A.4 Why Short Wires Fix the Problem

Short wires reduce:

• Resistance
• Inductance
• Voltage drop
• Noise pickup

This is why the <6 inch rule is so effective.


---
A.5 Final Recommendation

Never power a Pi 5 via USB‑C in a motorized robot.  

Use a dedicated buck converter with short, thick wires.

============================================
Appendix B — Short Wire Pathways
============================================

This appendix documents the engineering logic behind the short‑wire strategy.


---
B.1 Voltage Drop Calculation

Voltage drop formula:

Where R increases with wire length.

Example

18 AWG wire ≈ 0.0064 Ω/ft.

At 3 A load:

V_drop = 3 A * 0.0064 Ω = 0.0192 V per foot

A 2‑foot round‑trip path = ~0.04 V drop.
That’s enough to cause Pi 5 instability.


---
B.2 Inductance Effects

Long wires act as inductors.

Inductance causes:

• Voltage spikes
• Ringing
• Noise injection

Short wires reduce inductance dramatically.


---
B.3 Recommended Wire Lengths

Pi 5 power wires: < 6 inches
Motor power wires: < 12 inches
Encoder wires: < 18 inches (twisted)


---
B.4 Ground Return Path Strategy

Ground must return:

• Pi 5 → Buck converter
• Motor drivers → Battery
• Pico 2 → USB ground

Never mix high‑current and logic ground paths.


============================================
Appendix C — ROS Architecture Notes
============================================

This appendix expands on ROS node design, message flow, and debugging strategies.


---
C.1 Why ROS Nodes Are Split

Splitting nodes improves:

• Fault isolation
• Debuggability
• Modularity
• Maintainability

Node Groups

• Motor control
• Serial communication
• Odometry
• Diagnostics


---
C.2 Serial Bridge Reliability

The serial bridge must:

• Reconnect automatically
• Detect dropped packets
• Reset watchdog
• Publish diagnostics

Recommended Behavior

If serial port disappears:

• Stop motors
• Retry connection every 0.5 s
• Publish warning


---
C.3 Odometry Accuracy Notes

Odometry depends on:

• Correct wheel diameter
• Correct counts_per_rev
• Clean encoder signals
• Accurate wheelbase measurement

Calibration Procedure

1. Drive robot 1 meter
2. Compare encoder distance
3. Adjust wheel diameter parameter
4. Repeat until error < 1%

---
C.4 TF Tree Structure

map
 └── odom
      └── base_link
           └── base_laser (if LiDAR)

This structure is standard for differential‑drive robots.



============================================
Appendix D — Integration Details
============================================

This appendix includes wiring pinouts, serial protocol details, and recommended testing scripts.


---
D.1 Pico 2 Pinout Summary

Motor 1: IN1 = GPIO 2, IN2 = GPIO 3
Motor 2: IN1 = GPIO 4, IN2 = GPIO 5
Motor 3: IN1 = GPIO 6, IN2 = GPIO 7

Encoder 1: A = GPIO 10, B = GPIO 11
Encoder 2: A = GPIO 12, B = GPIO 13
Encoder 3: A = GPIO 14, B = GPIO 15


---
D.2 Serial Command Reference

Commands

SET M1 <duty> <dir>
SET M2 <duty> <dir>
SET M3 <duty> <dir>
ESTOP
RESET

Telemetry

ENC <m1> <m2> <m3>
SPD <m1> <m2> <m3>
FLT <motor> <code>


---
D.3 Recommended Test Scripts

Test PWM

SET M1 20 1
SET M1 50 1
SET M1 0 0

Test Encoders

Spin wheel by hand and verify:

ENC <counts>

Test Watchdog

Stop sending commands and verify motors stop.

---
D.4 Integration Checklist

[ ] Pi 5 powered from dedicated buck converter
[ ] Pi 5 power wires < 6 inches
[ ] Motor fuses installed
[ ] Bulk capacitors installed
[ ] Snubbers installed
[ ] TVS diodes installed
[ ] Encoder wires twisted
[ ] Serial bridge running
[ ] Watchdog enabled
[ ] Odometry verified

